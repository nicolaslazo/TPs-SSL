%{  /* seccion de definiciones */

#DEFINE YYDEBBUG 1
int flag_error=0;

%}

%%

%union{
	char  *t_cadena;
	float t_float;
	int t_entero;
	int t_tipo;	
}

/* los tokens son los simbolos no terminales, type son los terminales */
%token <t_entero>DIGITO
%token <t_cadena>CARACTERES 
%token MAYORIGUAL MENORIGUAL
%token DESIGUALDAD IGUALDAD
%token AND OR
%token error

%type expresion
%type identificador
%type num
%type constoctal constdec consthexa
%type listaSentencia sentencia sentCompuesta sentInteraccion sentSalto sentSeleccion sentenciaExp
%type listaDeclaraciones listaSentencia declaracion


%left '='
%right OR
%right AND
%right '<' '>' '>=' '<='		//aca faltaria igualdad,desigualdad, y en las reglas gramaticales tmb
%right '=!' '=='
%right '+' '-'
%right '*' '/' '%'
%right '^'
%right if else while do switch for return 

%%     /* Reglas gramaticales y las acciones */

expresion:
	
	| expresion '=' expresion			{$$ = $1;}
	| expresion OR expresion			{$$ = $1 || $3; }
	| expresion AND expresion			{$$ = $1 && $3; }
	| expresion MAYORIGUAL expresion		{$$ = $1 >= $3; }
	| expresion '>' expresion			{$$ = $1 > $3}
	| expresion MENORIGUAL expresion		{$$ = $1 <= $3; }
	| expresion '<' expresion			{$$ = $1 < $3}
	| expresion DESIGUALDAD expresion { $$ = $1 != $3;}
	| expresion '+' expresion   		{$$ = $1 + $3; } 
	| expresion '-' expresion  		{$$ = $1 - $3; }
	| expresion '*' expresion  		{$$ = $1 * $3; }
	| expresion '/' expresion   		{ if($3!=0){$$ = $1/$3; }else{ printf("\n Valor no reconocido para la division.");} }
	| expresion '^' expresion   		{$$ = pow($1, $3); }
	| identificador
	| num
	| LITERALCADENA

identificador : 
	| CARACTERES //noDigito
	| identificador CARACTERES
	| identificador DIGITO 

num : //num seria constanteEntera en la BNF de C
	| constdec 
	| constoctal
	| consthexa

constdec :
		| constdec DIGITO {if($1==0){flag_error=1; printf("Error, no es un numero decimal");}else{ flag_error=0; $$ = $1++$3;}} //preguntar: si esta bien, mi idea es que si detecta que el primer digito es cero me tire error, caso contrario que concatene los caracteres.

constoctal : 0
		| constoctal DIGITO // ACA IRIA DIGITO? 

consthexa : 0x DIGITO
		| 0X DIGITO
		| consthexa CARACTERES
		

sentencia :  sentCompuesta
	| sentenciaExp
	| sentSeleccion
	| sentInteraccion
	| sentSalto

sentCompuesta : 
	| listaDeclaraciones listaSentencia  //esta ggramatica es sentCompuesta -> {listaDeclaraciones listaSentencia} como pongo los llaves, bison entiende de llaves?

listaDeclaraciones : declaracion
	| listaDeclaraciones declaracion

listaSentencia : sentencia
	| listaSentencia sentencia

sentenciaExp :
	| exp

sentSeleccion : IF '(' expresion ')' sentencia	{if($3){$$=$4;}else{flag_error=1; printf("Error expresion invalida");}}
	| IF '(' expresion ')' sentencia ELSE sentencia  	{if(!$3){flag_error=1; printf("Error, condicion invalida");}else{ if($3){$$ = $4;}}else{ $$ = $5;} }
	| WHILE'(' expresion ')' sentencia {while($3){$$=$5; flag_error=0;}}
	| SWITCH'(' expresion ')' sentencia  {switch($3){ //como pongo aca lo de case break.. }}
	| DO sentencia WHILE'(' expresion')'  {do{$2}while($5);}
	| FOR'(' expresion ';' expresion ';' expresion ')' sentencia {for($3; $5; $7){$$ = $9;}}
	| RETURN expresion  {return $2;}
	| RETURN


void yyerror(char *s){ 
	printf("\n Esta sentencia es incorrecta : %s, s);
	printf("\n Presione cualquier tecla para salir...");
	/* getch() NOSE SI SE PUEDE PONER*/
}

main(){
	yyparse();	
}
